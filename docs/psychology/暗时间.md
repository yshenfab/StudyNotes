# Table of Contents

1. [暗时间](#org411d396)
    1. [暗时间](#org1b29de9)
    2. [设计你自己的进度条](#org1462194)
        1. [设计你自己的进度条](#orgf3cf4f4)
        2. [不要过早退出循环](#orgfabe9b8)
        3. [兴趣遍地都是，专注和持之以恒才是真正稀缺的](#org6825a93)
        4. [生活中的选择远比我们想象的要多，细微的选择差异造就了不同的人生](#org57ca978)
        5. [靠专业技能的成功是最具可复制性的](#org8298b67)
        6. [反思是让人得以改进自己的最重要的思维品质](#orgd11366a)
        7. [饿死在干草堆之间的驴子](#orgb54fac1)
        8. [一生的知识积累，自学的起码占 90%](#orgb8832b6)
    3. [如何有效的记忆与学习](#orgdc65c6d)
        1. [具体实践方法](#org55a42bc)
    4. [学习密度与专注力](#orge6b3a0a)
    5. [一直以来伴随我的一些学习习惯](#org384201f)
        1. [学习与思考](#org3d9259a)
        2. [时间和效率](#org483f76f)
        3. [时间和效率 2](#org5964719)
        4. [知识结构](#org0423d42)
        5. [习惯的养成](#orga2f000c)
2. [思维改变生活](#org233ad66)
    1. [逃出你的肖申克](#orgb21d0fa)
        1. [亲身经历才能明白?](#org644860b)
        2. [亲身经历了就一定明白吗？](#org2e4f9e1)
    2. [书写是为了更好地思考](#org5b405c8)
    3. [为什么你从现在开始就应该写博客](#org3112d1a)
    4. [我不想与我不能](#orgfbed006)
    5. [遇到问题为什么应该自己动手](#org184a871)
    6. [什么才是你的不可替代性和核心竞争力](#orgd026b97)
3. [跟波利亚学解题](#org4aee495)
    1. [跟波利亚学解题](#org8643b39)
    2. [锤子和钉子](#org0159f92)
        1. [（一）](#org90db8d9)
        2. [（二）](#orgafe3047)
    3. [鱼是最后一个看到水的](#org6d229a4)
        1. [C++](#org77d5d84)
    4. [知其所以然](#orgde72187)
    5. [为什么有必要知其所以然](#orgd2941cf)
    6. [康托尔、歌德尔、图灵——永恒的金色对角线](#org42a4620)
        1. [图灵的停机问题（The Halting Problem）](#org4281515)
        2. [Y Combinator](#orgb53c681)
        3. [歌德尔的不完备性定理](#orgf5012f0)
        4. [大道至简——康托尔的天才](#orga4ee8eb)
    7. [数学之美番外篇：快排为什么那样快](#org2fbdf69)
    8. [数学之美番外篇：平凡而又神奇的贝叶斯方法](#orgf5a0c4d)
        1. [历史](#orgdec1f41)
        2. [一个例子：自然语言的二义性](#orgda537e0)
        3. [贝叶斯公式](#org116798b)

人人都该学点心理学
blog 推荐：负喧琐话 <http://blog.csdn.net/g9yuayon>

<a id="org411d396"></a>

# 暗时间

<a id="org1b29de9"></a>

## 暗时间

- 大脑就像 CPU，如果不思考就像 CPU 运行 idle 进程一样，要善于利用思维时间
- 时间对每个人并不均等，衡量一个人活了多久应该用思维时间来计算
- 一件事情的实际投入是时间和效率的乘积
- 暗时间：走路、买菜、洗脸洗手、坐车、逛街、出游、吃饭、睡觉等等
- 程序思维：任务切换会耗费额外的花销，所以专注比不专注更高效，这也是暗时间
- 高效学习：迅速进入专注状态 + 长期保持专注状态(思维体力) + 抗干扰

<a id="org1462194"></a>

## 设计你自己的进度条

<a id="orgf3cf4f4"></a>

### 设计你自己的进度条

- 进度条相当于给自己心理暗示(定心丸)，能预估什么时候会达到 100%
- 人会对不确定的未来、不确定的时间投入感到恐惧，这样的心理下人就会选择退出

<a id="orgfabe9b8"></a>

### 不要过早退出循环

- 遇到困难不要畏难，不要轻易放弃
- 过早退出也是因为对未来的不确定性、对投资时间最终无法收到回报的恐惧
- 感受到的困难越大则恐惧越大，恐惧越大则暗示需要投资的时间越多
- “畏难”所畏惧的不是困难本身，而是困难所暗示的时间经济学意义
- 高德纳：过早退出是一切失败的根源

<a id="org6825a93"></a>

### 兴趣遍地都是，专注和持之以恒才是真正稀缺的

- 区别人的不是兴趣，而是毅力，即便没有兴趣，专注和持之以恒也能成为专家
- 兴趣的很大一类来源是——"我擅长做这件事"

<a id="org57ca978"></a>

### 生活中的选择远比我们想象的要多，细微的选择差异造就了不同的人生

<a id="org8298b67"></a>

### 靠专业技能的成功是最具可复制性的

<a id="orgd11366a"></a>

### 反思是让人得以改进自己的最重要的思维品质

<a id="orgb54fac1"></a>

### 饿死在干草堆之间的驴子

- 不要因为无法做出决定而推迟决定，推迟决定是最差的决定，白白浪费了时间
- 不管多纠结，都要好好思考和调查之后做出一个决定并坚持下去

<a id="orgb8832b6"></a>

### 一生的知识积累，自学的起码占 90%

<a id="orgdc65c6d"></a>

## 如何有效的记忆与学习

- 你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来
- 联想记忆(记忆编码)，提供更多的提取线索，任何一个线索被触发都可能顺藤摸瓜地拎出整条记忆来
- 理解性的记忆，富含线索
- 抽象问题，触及本质，有效提取知识

<a id="org55a42bc"></a>

### 具体实践方法

1. 养成习惯，经常主动回顾一段时间学到的东西
2. 创造回忆的机会
    2.1) 经常与别人讨论，或者讲给别人听：教是最好的学
    2.2) 整理笔记
    2.3) 书写：思考、关联、增加线索等等
3. 设身处地“虚拟经历”别人经历过的事情
4. 抽象和推广
5. 联想/比较自身的经历

<a id="orge6b3a0a"></a>

## 学习密度与专注力

- 学习密度:重视积累的力量
- 专注力也是一种习惯，迅速进入专注的状态
- 思维体力：持续集中注意力的时间，注意力造就非凡专家，天才来源于长期的专注的训练

<a id="org384201f"></a>

## 一直以来伴随我的一些学习习惯

<a id="org3d9259a"></a>

### 学习与思考

- Google & Wiki
- 看书挑剔，只看经典
- 做读书笔记
- 利用暗时间思考
- 多看心理学和思维的书
- 学习一项知识必须问自己三个重要的问题：
  它的本质是什么，它的第一原则是什么，它的知识结构是怎样的？
- 学习中经常问自己： 1.你的问题到底是什么（提醒自己不要偏离问题） 2.到现在为止,我有什么收获(经常总结) 3.设想在讲给别人听(有声思考) 4.设想需要讲给一个不懂的人听(挖掘背后最本质的解释) 5.反省和注意自己的思维过程 6.养成反驳自己想法的习惯 7.人的思维天生就是极易流于表面来理解事物的(追寻知识的本质)

<a id="org483f76f"></a>

### 时间和效率

- 趁着对一件事情有热情的时候，一股脑儿把万事开头那个最难的阶段熬过去
- 要事优先
- 重要的事要营造大块时间来完成
- 善于利用小块时间
- 重视知识的本质
- 重视积累的力量，万事提前准备
- 学习之前先判断一个东西值不值得学习：
  学的到底是什么、重要吗、需要在这个时候学习吗、未来有什么价值、是不是你真正希望做的
- 退订 RSS:真正宝贵的信息,在其他来源你也会接触到
- 多总结最近得到的新知识
- 多读书
- 制定简要的阅读计划

<a id="org5964719"></a>

### 时间和效率 2

- 根据主题查阅资料,而不是根据资料查阅主题（书只看章节，当字典用）
  举例：比如看某个算法，搜集不同资料，看每个人从不同的角度如何讲述的
- 区分好资料与坏资料
- 学习一个东西之前,首先在大脑中积累充分的“疑惑感”
- 有选择地阅读(信息密度低,不需要思考的快速略读)
  3 步骤:问题是什么?方案是什么?例子是什么?
- 阅读的分类:一类是知识的,一类是思维的
- 利用时间碎片:任何一点时间都可以用于阅读
- 为什么看不懂?你看得不够使劲/涉及了你不懂的概念/作者讲的顺序不对
- 阅读之前先获得一本书质量的大致评估
- 如何搜寻好书

<a id="org0423d42"></a>

### 知识结构

- 抓住不变量

<a id="orga2f000c"></a>

### 习惯的养成

- 人评判一个信念的标准是 satisficing 原则而不是 optimizing

<a id="org233ad66"></a>

# 思维改变生活

<a id="orgb21d0fa"></a>

## 逃出你的肖申克

<a id="org644860b"></a>

### 亲身经历才能明白?

- 切身体验:更加强烈和深刻
- 别人口中的故事:也许只是事情的一个方面,难免受到他们自己观念的影响而产生偏见
- 为什么:别人给你讲道理只能告诉你怎么做(how),而难以解释为什么(why)
- 世界是复杂的:单一因果来解释事情几乎总是不恰当的
- 未来是不确定的:头脑清醒,尽量不错失机遇,改善个人因素能大大增加成功的几率
- 别人的道理,自己的事情:知识经验跨情境转移
- 认知失调与自我辩护
- 失败即成功:总结经验教训,失败揭露出的信息往往比成功多
- 情绪对照
- 天性:大脑进化选择出来的天性,在判断与决策时的优先级总是最高的
  两个大脑:理性大脑(进化年代较新近的大脑皮层,具备自我意识,分析,计划,抽象,语言等复杂功能)和原始大脑(进化年代久远的大脑区域,适应于远古社会,主管情绪及一些原始需求和条件反射,如生存,繁衍,道德直觉等等)
  为什么总是感到不满足?感到满足就不会进取,不进取就会被淘汰(优胜劣汰)&#x2026;
  自然选择过程试图最优化的目标函数并不是"幸福感",而是"繁衍概率"
  需要用理性大脑去说服原始大脑
- 习惯

<a id="org2e4f9e1"></a>

### 亲身经历了就一定明白吗？

- 很傻很天真的条件反射
  没有好结果并不代表过程错了，正确的结果并不代表方法一定正确
  看重过程而不是单次的结果
  再好的过程也可能会偶尔失利，但从长远统计，好的过程总体上必然导致更好的结果
- 认知偏差
  自我服务偏差：将失败归因于外界因素，将成功归因于自己的能耐
- 情绪系统
  我们平常的决策与判断强烈地依赖于情绪系统的输出

1. 不需要亲历也能明白——理性的力量

    - 让事实替代我们进行了思考和推理
    - 普通人从自己的错误中学习，聪明人从别人的错误中学习（在别人跌倒的地方跳过去）
    - 大脑中走的越远，现实中就走的越稳；大脑中失败的次数越多，现实中失败的次数就越少

2. 仁者见仁智者见智?从视觉错觉到偏见

    - 当大脑中的两个假设相冲突的时候，更强硬的那个获胜
    - 先验假设
    - 日常生活中的事件，总有一个平凡的解释和一个疯狂的解释
    - 我们总是混淆“事实”和“推断”（尤其是我们对推断的确信度很高或对我们有利的时候）
    - 很多时候我们根本无法看到或设想另一种可能性
    - 开阔视野，多积累知识，以及和具有不同知识背景的人讨论
    - 仁者见仁智者见智：1.偏见 2.立场 3.选择性关注
    - Open Mind: 1.这只是一种可能，未必是唯一的可能 2.想不出其他解释不代表就不存在其他解释

3. 遇见 20 万年前的自己

    - 正确而理性的做法是永远都勇敢地迈出第一步
    - GTD 的原理：“情形正在变好”可以带来正面情绪，从而激励个体把事情执行到底
    - 以“诱使”或“要挟”的认知方法来促使自己执行一件事

4. 理智与情感

    - 我们理性的大脑非常善于对自己的行为作出立即的、看上去合理的解释
    - 我们知道答案，却往往不知道求解的真正思维过程
    - 只要我们的情绪大脑（原始大脑）首先认定一件事，那么理性大脑就会屈服，并会寻找利于自己的解释
    - 客观意味着承认存在未知信息的可能性，理性意味着能够从对立面的视角去看问题和思考。
    - 克服大脑天生的缺陷：用进废退
    - 习惯之所以难以改变，就是因为习惯是自我巩固的——越用越强，越强越用
    - 要想从既有习惯中跳出来，必然要依赖外界的力量——对于心理机制的知识
    - 能够改变既有的习惯，依靠的不是自制力，而是知识

5. 我们为什么会欺骗自己？（my title）

    当人们为一件事付出的越多（金钱/时间/社会关系），这些既有付出会对他们的思维产生越来越大的影响（经济学中的“沉没成本”），
    我们的思想被迫对自己的行为作出合理的解释（“认知失调”），因为谁也不希望自己那么大的付出是愚蠢而错误的，因此理性大脑
    不再客观，开始自欺欺人。

<a id="org5b405c8"></a>

## 书写是为了更好地思考

1. 书写是对思维的备忘
2. 书写是对思维的缓存
3. 书写是与自己的对话
4. 书写是与别人的交流
5. 有时候，语言自己也会思考

<a id="org3112d1a"></a>

## 为什么你从现在开始就应该写博客

1. 能够交到很多志同道合的朋友
2. 书写是为了更好地思考
3. “教”是最好的“学”
4. 讨论是绝佳的反思
5. 激励你去持续学习和思考
6. 学会持之以恒地做一件事
7. 一个长期的价值博客是一份很好的简历

<a id="orgfbed006"></a>

## 我不想与我不能

- 自利归因：把一件事发生的原因归结为对自己有利的那种情况。
- 人生不得意往往有 2 个原因：外因（不可控），内因（自由意志和主观能动性，可控）

<a id="org184a871"></a>

## 遇到问题为什么应该自己动手

- 寻找捷径是很聪明的做法
- 寻找捷径只是小聪明
- 困难的路越走越容易，容易的路越走越难

<a id="orgd026b97"></a>

## 什么才是你的不可替代性和核心竞争力

- 技术路线的选择重要但不具有决定性
- **个人核心竞争力是他独特的个性知识经验组合**
  如果这种组合：1.绝无仅有 2.在实践中有价值 3.具有可持续发展性
  那么你就具备核心竞争力
- **具有相当程序不可替代性的知识技能组合** 1.专业领域技能 2.跨领域的技能（解决问题的能力、创新思维、判断与决策能力、批判性思维、表达沟通能力等等） 3.学习能力 4.性格要素（专注、坚持、自省、好奇、自信、谦卑等等）

<a id="org4aee495"></a>

# 跟波利亚学解题

<a id="org8643b39"></a>

## 跟波利亚学解题

- 联想、归约、推导、启发式思考方法(heuristics)
- 把问题本身当条件，从它推导出结论，再从结论推导出更多的结论，直到我们发现已经出现了真正已知的条件。这个过程称为分析。
- 探索源头
- 《How To Solve It》中的启发式思维方法： 1.时刻不忘未知量（即时刻不忘到底要求什么，问题是什么） 2.用特例启发思考 3.反过来推导（结论往往蕴含丰富的条件） 4.试错 5.调整题目的条件（如增加/删除/改变条件） 6.求解一个类似的题目（“迁移”） 7.列出所有可能跟问题有关的定理或性质 8.考察反面，考察其他所有情况 9.将问题泛化，并求解这个泛化后的问题（“发明者悖论”） 10.意识孵化法（“思维体力”，一直放在脑子里思考） 11.烫手山芋法（提问，把问题扔给别人）
- 一点思考 1.联想的法则：知识同样是一把双刃剑，一方面它提供给我们解决问题的捷径优势，另一方面也是思维的桎梏 2.知识，知识 3.好题目，坏题目 4.一个好习惯 5.练习，练习：将外显记忆转化为内隐记忆 6.启发式的局限性
  启发式方法在 2 个层面上起作用：1) 辅助联想起 soft knowledge 2) 辅助探索出 hard knowledge
  启发式方法的局限性也存在于这 2 个方面： 1) 有些联系通过“启发”想不起来 2) 许多 hard knowledge 是不能被启发探索出来的 7.总结的意义

<a id="org0159f92"></a>

## 锤子和钉子

<a id="org90db8d9"></a>

### （一）

- 心中有锤子（技能），看什么都是钉子：思维定势/局限，人倾向于在既有框架下去解决问题，而这个过程很难觉察到框架约束的存在
- 没有锤子是万万不行的
- 正确的态度：手中有锤，心中无锤

<a id="orgafe3047"></a>

### （二）

- 如果你想钉一个钉子，所有东西看上去都像锤子：专注于你要解决的问题，那么你所看到的东西就会呈现出以往你没有看到的一面
- 把自己变成钉子，就是顿悟(eureka)的奥秘

<a id="org6d229a4"></a>

## 鱼是最后一个看到水的

- 普通人遵守规则，牛人无视规则，伟人创造规则
- Think out of the box.

<a id="org77d5d84"></a>

### C++

- 学习 C++的第一原则是什么？关注基本的概念和技术，而非特定的语言特性，尤其不是 C++中细枝末节的语言细节。
- 使用 C++的第一原则是什么？将你的（与语言无关的）设计理念（概念）直接映射为 C++中的类或模板，即脱离语言思考、使用语言实现。

<a id="orgde72187"></a>

## 知其所以然

- 比如看一个算法，不要看算法逻辑的描述，要看算法诞生过程背后的思想（寻找原始出处）
- 我们要的不是相对论，而是诞生相对论的那个大脑。我们要的不是金蛋，而是下金蛋的那只鸡。
- 思考一个问题过程中的 2 种思维形式：1.联想 2.演绎&归纳
- 如果说问题求解是一部侦探小说，那么算法只是结局，而思考过程才是情节！

<a id="orgd2941cf"></a>

## 为什么有必要知其所以然

- 看定理必看证明，在没有明白背后的证明之前，任何一个定理对你来说都是等价的——等于背诵乘法口诀
- 去理解一个定理的证明，你就很难再忘掉它
- 这是个树状知识结构，越往上层走，需要记忆的节点就越少
- 知道怎么做是从正确（高效）解法得到的，而知道为什么必须得那样做则往往是从错误（低效）的解法当中得到的

<a id="org42a4620"></a>

## 康托尔、歌德尔、图灵——永恒的金色对角线

<a id="org4281515"></a>

### 图灵的停机问题（The Halting Problem）

- 停机问题：不存在这样一个程序（算法），它能够计算任何程序（算法）在给定输入上是否会结束（停机）。
- 反证

<a id="orgb53c681"></a>

### Y Combinator

1. lambda calculus(lambda 算子)

    1. 基本语法（BNF）：

        <expr> ::= <identifier>
        <expr> ::= lambda <identifier-list>. <expr>
        <expr> ::= (<expr> <expr>)

        - 前两条语法用于生成 lambda 表达式（lambda 函数），如：lambda x y. x+y
          haskell 里用“\\”代替希腊字母 lambda，所以写成\\ x y. x+y
          这是一个匿名的加法函数，它接受 2 个参数，返回两值相加的结果
          实际上 lambda calculus 里一切都只不过是文本替换，有点像 C 语言里的宏
          第三条语法可以给出更简洁的中缀表达，即(+ x y)
          函数的定义出来了，最后一条规则就是用来调用一个 lambda 函数的：((lambda x y. x+y) 2 3)，类似于 f(x,y)写成(f x y)的形式
          为了简洁，我们：let Add = (lambda x y. x+y)，进而可以写成(Add 2 3)

    2. 两条公理：

        - Alpha 转换公理：如"lambda x y. x+y"转换为"lambda a b. a+b"
        - Beta 转换公理：如"(lambda x y. x+y) 2 3"转换为"2+3"

2. 递归的迷思

    - 递归：函数定义中用到自身，自身调用自身
    - 就以上两条公理，我们无法用 lambda 表示递归函数，比如计算阶乘
      f(n): if n==0 return 1 else return n\*f(n-1)
    - 我们很容易想到：lambda n. If<sub>Else</sub> n==0 1 n\*<self>(n-1)
      但在 C 语言里<self>可以填函数名本身，而 lambda 算子系统里的 lambda 表达式（函数）是没有名字的
    - 一次失败的尝试：
      let F = lambda n. If<sub>Else</sub> n==0 1 n\*F(n-1)
      let F 在它所代表的 lambda 表达式还没有完全定义出来之前，是不可以用 F 这个名字的

3. 一次成功的尝试

    - 软件工程里的一条黄金定律：任何问题都可以通过增加一个间接层来解决
    - 刚才不成功的定义：lambda n. If<sub>Else</sub> n==0 1 n\*<self>(n-1)
      既然不能在<self>直接填函数自身，那我们可以增加一个参数，也就是说把<self>参数化：
      lambda self n. If<sub>Else</sub> n==0 1 n\*self(n-1)
      现在我们调用这个函数的时候，只需要加传一个参数 self，这个参数不是别人，正是这个函数自身：
      let P = lambda self n. If<sub>Else</sub> n==0 1 n\*self(n-1)
      比如计算 3 的阶乘：P(P,3)
      可惜还差一点，我们分析 P(P,3)这个调用，按 Beta 转换规则展开：
      If<sub>Else</sub> n==0 1 n\*P(n-1)
      这里 P(n-1)虽然调用到了 P，然而只给出了一个参数，而 P 的定义需要 2 个参数（self 和 n）
      为了让 P(n-1)变正确，我们还得加个参数，于是我们稍微修改一下 P 的定义：
      let P = lambda self n. If<sub>Else</sub> n==0 1 n\*self(self, n-1)

4. 不动点原理

    - 我们假设一个完美的递归函数 power：
      power(n): if n==0 return 1; else return n\*power(n-1)
      重新考虑刚才的 P(P,3)，一开始传递了一个有缺陷的 P 为参数，于是我们进行了修改
      那如果我们试着这样 P(power,3)传递一个真正的递归函数 power 呢？
      展开 P(power,3): If<sub>Else</sub> 3==0 1 3\*power(3-1)
      power(3-1)会直接计算 2 的阶乘，所以 P(power,3)会一直计算出 3 的阶乘
      设想的这个 power 是为了引入不动点的概念
    - 什么是不动点？
      在 lambda 算子系统里，如果给一个 lambda 函数的参数不足，则得到的就是一个新的 lambda 函数，
      这个新的 lambda 函数所接受的参数也就是你尚未给出的那些参数。换句话说，即调用一个 lambda
      函数可以分若干步来进行，每次只给出一部分参数，而只有等所有参数都给齐了，函数的求值结果
      才能给出来，否则你得到的就是一个“中间函数”。
      P(power)展开是: If<sub>Else</sub> n==0 1 n\*power(n-1) 参数 n 待定
      不妨写成 lambda n. If<sub>Else</sub> n==0 1 n\*power(n-1)
      我们再定义 power 试试: let power = lambda n. If<sub>Else</sub> n==0 1 n\*power(n-1)
      一模一样！也就是说 P(power)展开后跟 power 是一样的，即：
      P(power) = power
      这就是不动点。即对于函数 P 来说 power 是这样一个“点”：当把 P 用到 power 身上的时候，得到的结果仍然
      还是 power，也即 power 这个“点”在 P 的作用下是“不动”的。
      可惜这一切都建立在一个不存在的 power 的基础上！
      我们再假设存在一个神奇的函数 Y，把 Y 用到任何伪递归的函数 F 上就能得到 f，即：
      Y(F) = f
      而 F(f) = f，所以我们得到：Y(F) = f = F(f) = F(Y(F))
      也就是说 Y 具有性质：Y(F) = F(Y(F))

5. 铸造 Y Combinator

    let Y = lambda F.
    let f<sub>gen</sub> = lambda self. F(self(self))
    return f<sub>gen</sub>(f<sub>gen</sub>)

<a id="orgf5012f0"></a>

### 歌德尔的不完备性定理

任何足够强到蕴含了皮亚诺算数系统（PA）的一致（即无矛盾）的系统都是不完备的，
所谓不完备，也就是说在系统内存在一个为真但无法在系统内推导出的命题。

- 命题 P：P 处于形式系统 T 中，P 不可在系统 T 内证明。
- 一旦这个命题能够在 T 中表达出来，我们就可以得出“P 为真但无法在 T 内推导出来”
- G(g): UnPr(G(g)) （从歌德尔公式我们直接看到了 Y Combinator！）
- 以上只是第一不完备性定理，还有一个推论被称为第二不完备性定理：
  任一系统 T 内无法证明这个系统本身的一致性。

<a id="orga4ee8eb"></a>

### 大道至简——康托尔的天才

无穷集合、超限数

1. 神奇的一一对应

    - 两个无穷集合“大小”一样当且进当它们的元素之间能够构成一一对应
      比如偶数集合与自然数集合
    - 除了一一对应，还有不能构成一一对应的两个无穷集合，比如实数集合与自然数集合
      因为实数集不可列举，由此引入对角线法

2. 对角线法——停机问题的深刻含义

    反证，具体证明见 page 215-218

3. 罗素悖论

    R = {X:X 不属于 X}
    依然是用对角线法反证

<a id="org2fbdf69"></a>

## 数学之美番外篇：快排为什么那样快

- 核心：算法每步都是概率均等的比较，即留下一半的可能性
- 从信息论的角度解释：只有提出每种答案的概率都均等的问题，才能获得最大信息量
- 为什么快排其实也不是那么快：概率不均等的比较
- 基排（radix sort）为什么那么快？概率均等的比较
- 所有基于比较的排序都逃脱不了 nlogn 的宿命

<a id="orgf5a0c4d"></a>

## 数学之美番外篇：平凡而又神奇的贝叶斯方法

概率论只不过是把常识用数学公式表达了出来。——拉普拉斯

<a id="orgdec1f41"></a>

### 历史

- 源于解决一个“逆概”问题：在此之前人们已经可以计算正向概率，比如袋子里 N 个白球，M 个黑球，摸一个球是黑球的概率多大？
  但问题反过来，如果事先不知道袋子里黑白球的比例，闭着眼睛摸一个或好几个球，观察这些取出的球的颜色，可以对袋子里黑白球的比例作出什么样的推测？
- 现实世界是不确定的，人类的观察能力是有局限性的
- 我们需要： 1.算出各种不同猜测的可能性大小（计算特定假设的后验概率，对于连续的假设空间则是计算假设的概率密度） 2.算出最靠谱的猜测是什么（模型比较，如果不考虑先验概率就是最大似然方法）

<a id="orgda537e0"></a>

### 一个例子：自然语言的二义性

- The girl saw the boy with a telescope.

<a id="org116798b"></a>

### 贝叶斯公式

- 60%男生，40%女生，男生总是穿长裤，女生一半长裤一半短裤。遇到了 N 个穿长裤的人，问有多少女生/多少男生。
- 假设学校里总人数为 U，于是
  穿长裤的男生个数有： U \* P(Boy) \* P(Pants|Boy)，其中 P(Boy)=60%，P(Pants|Boy)是条件概率，即在 Boy 这个条件下穿长裤的概率，这里是 100%
  穿长裤的女生个数有： U \* P(Girl) \* P(Pants|Girl)，其中 P(Girl)=40%，P(Pants|Girl)=50%
  两者一比就得出了答案
- 将答案形式化，我们要求的是 P(Girl|Pants)，即穿长裤的人里有多少女生，
  而我们的计算结果是 U \* P(Girl) \* P(Pants|Girl) / (U \* P(Boy) \* P(Pants|Boy) + U \* P(Girl) \* P(Pants|Girl))
  即 P(Girl|Pants) = P(Girl)\*P(Pants|Girl) / (P(Boy)\*P(Pants|Boy) + P(Girl)\*P(Pants|Girl))
  分母其实就是 P(Pants)，分子其实就是 P(Pants,Girl)
  一般形式就是：P(B|A) = P(AB) / P(A)，或 P(B|A) \* P(A) = P(AB)

1. 最大似然的 2 个问题

    1. 并不能提供决策的全部信息
    2. 即便一个猜测与数据非常符合，也并不代表这个猜测就是更好的猜测，因为这个猜测本身的可能性也许就非常低
        比如：-1 3 7 11 可以说是等差数列，也可以说是多项式-x<sup>3</sup>/11 + 9/11\*x<sup>2</sup> + 23/11 把前项当作 x 代入后的计算结果

2. 奥卡姆剃刀

    如果两个理论具有相似的解释力度，那么优先选择那个更简单的
