<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Table of Contents - Study Notes</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Table of Contents";
        var mkdocs_page_input_path = "tools/makefile.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Study Notes
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Introduction</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Algorithm</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../algorithm/alg_blog_note/">Alg blog</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../algorithm/algorithms_4th_edition/">Algorithms (4th Edition)</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Blockchain</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../blockchain/blockchain/">Blockchain</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Deep Learning</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../deep_learning/google-machine-learning-crash-course/">Google ML Crash Course</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../deep_learning/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">Python机器学习</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../deep_learning/dive_into_deep_learning/">Dive into Deep Learning</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Mathematics</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../mathematics/beauty_of_mathematics/">数学之美</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../mathematics/statistics_concepts_and_controversies/">统计学的世界</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Psychology & Mind</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BF%83%E7%90%86%E5%AD%A6/">与众不同的心理学</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E5%86%B3%E7%AD%96%E4%B8%8E%E5%88%A4%E6%96%AD/">决策与判断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E6%9A%97%E6%97%B6%E9%97%B4/">暗时间</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E4%BD%A0%E7%9A%84%E7%81%AF%E4%BA%AE%E7%9D%80%E5%90%97/">你的灯亮着吗</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E6%B2%9F%E9%80%9A%E7%9A%84%E8%89%BA%E6%9C%AF/">沟通的艺术</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E5%BD%B1%E5%93%8D%E5%8A%9B/">影响力</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E4%B8%93%E6%B3%A8%E5%8A%9B/">专注力</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Python</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../python/effective_python/">Effective python</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../python/pythonic/">pythonic</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../python/py_tips/">py tips</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../python/python3/">python3</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../python/numpy/">numpy</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Research</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../research/%E5%83%8F%E5%A4%96%E8%A1%8C%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83%EF%BC%8C%E5%83%8F%E4%B8%93%E5%AE%B6%E4%B8%80%E6%A0%B7%E5%AE%9E%E8%B7%B5/">像外行一样思考，像专家一样实践</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Startup</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../startup/how_google_works/">How Google Works</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../startup/startup/">startup</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Tools</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../practical_vim/">vim</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../shell/">shell</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../git/">git</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../markdown/">markdown</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Other</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../other/history_of_quantum_physics/">上帝掷骰子吗？量子物理史话</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../other/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%847%E4%B8%AA%E4%B9%A0%E6%83%AF/">高效能人士的7个习惯</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../other/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/">底层逻辑</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../other/%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF/">高效程序员的45个习惯</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Todo</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../todo/todo/">TODO</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Study Notes</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li><li>Table of Contents</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="table-of-contents">Table of Contents</h1>
<ol>
<li><a href="#orge4bd9d6">Makefile</a><ol>
<li><a href="#orga8fcdf9">概述</a></li>
<li><a href="#orgde4089b">关于程序的编译和链接</a></li>
<li><a href="#org9db7582">Makefile介绍</a></li>
<li><a href="#orgf20546c">Makefile总述</a></li>
<li><a href="#orgf1e2597">书写规则</a></li>
<li><a href="#orgee36bab">书写命令</a></li>
<li><a href="#org492bbdb">使用变量</a></li>
<li><a href="#org1fa0019">使用条件判断</a></li>
<li><a href="#org47b5f87">使用函数</a></li>
<li><a href="#orgfbe4503">make的运行</a></li>
<li><a href="#org140df06">隐含规则</a></li>
<li><a href="#orgdce9234">使用make更新函数库文件</a></li>
<li><a href="#orgdb4c6a9">后序</a></li>
</ol>
</li>
</ol>
<p><a id="orge4bd9d6"></a></p>
<h1 id="makefile">Makefile</h1>
<p><a id="orga8fcdf9"></a></p>
<h2 id="_1">概述</h2>
<ul>
<li>Windows的IDE都为你做了这个工作</li>
<li>makefile关系到了整个工程的编译规则</li>
<li>一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定
    哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，
    因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令</li>
<li>自动化编译，一个make命令，整个工程完全自动编译，makefile都成为了一种在工程方面的编译方法</li>
</ul>
<p><a id="orgde4089b"></a></p>
<h2 id="_2">关于程序的编译和链接</h2>
<ul>
<li>编译：把源文件编译成中间代码文件，在Windows下也就是.obj文件，UNIX下是.o 文件，即Object File</li>
<li>链接：把大量的Object File合成执行文件</li>
<li>编译时，编译器需要的是语法的正确，函数与变量的声明的正确；
    链接，需要告诉编译器头文件的所在位置(头文件中应该只是声明，而定义应该放在C/C++文件中)</li>
<li>链接时，主要是链接函数和全局变量，目标文件(O文件或是OBJ文件)来链接我们的应用程序，链接器并不管函数所在的源文件，
    只管函数的中间目标文件，在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，
    这对于编译很不方便，所以我们要给中间目标文件打个包，在Windows下这种包叫“库文件”(Library File)，
    也就是.lib 文件，在UNIX下是Archive File，也就是.a文件</li>
</ul>
<p><a id="org9db7582"></a></p>
<h2 id="makefile_1">Makefile介绍</h2>
<p>规则：</p>
<ol>
<li>如果工程没有被编译过，那么所有C文件都要编译并被链接</li>
<li>如果某几个C文件被修改，那么只编译被修改的C文件，并链接目标程序</li>
<li>
<p>如果头文件被修改，那么需要编译引用了这几个头文件的C文件，并链接目标程序</p>
</li>
<li>
<p>Makefile的规则</p>
<ul>
<li>target &#x2026;: prerequisites &#x2026;
    command
    &#x2026;
    &#x2026;</li>
<li>target也就是一个目标文件,可以是 Object File,也可以是执行文件。还可以是一个标签(Label)</li>
<li>prerequisites 就是,要生成那个 target 所需要的文件或是目标</li>
<li>command 也就是 make 需要执行的命令(任意的 Shell 命令)</li>
<li>这是一个文件的依赖关系,也就是说target这一个或多个的目标文件依赖于prerequisites中的文件,
    其生成规则定义在command中。说白一点就是说prerequisites中如果有一个以上的文件比target文件要新的话,
    command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</li>
</ul>
</li>
<li>
<p>一个示例</p>
<ul>
<li>make会比较targets文件和prerequisites文件的修改日期,如果prerequisites文件的日期要比targets文件的日期要新,
    或者target不存在的话,那么make就会执行后续定义的命令</li>
</ul>
</li>
<li>
<p>make是如何工作的</p>
<ol>
<li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</li>
<li>如果找到,它会找文件中的第一个目标文件(target),在上面的例子中,他会找到“edit”这个文件,并把这个文件作为最终的目标文件。</li>
<li>如果 edit 文件不存在,或是 edit 所依赖的后面的 .o 文件的文件修改时间要比 edit这个文件新,那么,他就会执行后面所定义的命令来生成 edit 这个文件。</li>
<li>如果 edit 所依赖的.o 文件也存在,那么 make 会在当前文件中找目标为.o 文件的依赖性,如果找到则再根据那一个规则生成.o 文件。(这有点像一个堆栈的过程)</li>
<li>当然,你的 C 文件和 H 文件是存在的啦,于是 make 会生成 .o 文件,然后再用 .o 文件生命 make 的终极任务,也就是执行文件 edit 了。</li>
</ol>
</li>
<li>
<p>makefile中使用变量</p>
<ul>
<li>makefile的变量也就是一个字符串,理解成C语言中的宏可能会更好</li>
<li>example:</li>
</ul>
<p>edit : main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o
cc -o edit main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o
上面一堆.o文件，用一个变量表示：
objects = main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o
然后在makefile中以"$(objects)"的方式使用变量
edit: $(objects)
cc -o edit $(objects)</p>
</li>
<li>
<p>让make自动推导</p>
<p>GNU的make很强大，如果make找到一个whatever.o，那么whatever.c就会是whatever.o的依赖文件，并且
cc -c whatever.c也会被推导出来。</p>
<ul>
<li>example:</li>
</ul>
<p>objects = main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o</p>
<p>edit: $(objects)
cc -o edit $(objects)</p>
<p>main.o: defs.h
kbd.o: defs.h command.h
command.o: defs.h command.h
display.o: defs.h buffer.h
insert.o: defs.h buffer.h
search.o: defs.h buffer.h
files.o: defs.h buffer.h command.h
utils.o: defs.h</p>
<p>.PHONY: clean
clean:
rm edit $(objects)</p>
<ul>
<li>隐晦规则</li>
<li>伪目标文件：.PHONY</li>
</ul>
</li>
<li>
<p>另类风格的makefile</p>
<p>上面的例子里：
$(objects): defs.h
kbd.o command.o files.o: command.h
display.o insert.o search.o files.o: buffer.h
但是这样文件依赖关系就显得有些凌乱</p>
</li>
<li>
<p>清空目标文件的规则</p>
<p>clean从来都是放在文件的最后</p>
<ul>
<li>一般风格：</li>
</ul>
<p>clean:
rm edit $(objects)</p>
<ul>
<li>更稳健的做法：</li>
</ul>
<p>.PHONY: clean
clean:
-rm edit $(objects)
其中减号"-"表示忽略遇到的错误</p>
</li>
</ol>
<p><a id="orgf20546c"></a></p>
<h2 id="makefile_2">Makefile总述</h2>
<ol>
<li>
<p>Makefile里有什么</p>
<p>主要包含了5个东西：</p>
<ol>
<li>显式规则
    如何生成一个或多的的目标文件，指明要生成的文件、文件的依赖文件、生成的命令</li>
<li>隐晦规则
    利用make的自动推导功能，简略书写makefile</li>
<li>变量的定义
    定义字符串，类似C语言中的宏</li>
<li>文件指示
    3个部分：<ol>
<li>一个是在一个Makefile中引用另一个Makefile，就像include一样</li>
<li>另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样</li>
<li>还有就是定义一个多行的命令</li>
</ol>
</li>
<li>注释
    “#”注释，“\#”转义
    Makefile中的命令，**必须要以TAB键开始**</li>
</ol>
</li>
<li>
<p>Makefile的文件名</p>
<ul>
<li>默认为Makefile, makefile或GNUmakefile</li>
<li>也可以自己指定，比如Make.jlinno，以make -f Make.jlinno运行</li>
</ul>
</li>
<li>
<p>引用其他的Makefile</p>
<ul>
<li>语法：include <filename> 没有#号
    filename可以是当前操作系统shell的文件模式（可以包含路径和通配符）
    include前面可以有一些空字符，但绝不能是TAB</li>
<li>example: 有几个Makefile: a.mk, b.mk, c.mk，还有一个文件foo.make，以及一个变量$(bar)包含了e.mk和f.mk
    那么可以写成
    include foo.make **.mk $(bar)</li>
</ul>
</li>
<li>
<p>环境变量MAKEFILES</p>
</li>
<li>
<p>make的工作方式</p>
<p>执行步骤：</p>
<ol>
<li>读入所有的Makefile</li>
<li>读入被include的其它Makefile</li>
<li>初始化文件中的变量</li>
<li>推导隐晦规则，并分析所有规则</li>
<li>为所有的目标文件创建依赖关系链</li>
<li>根据依赖关系，决定哪些目标要重新生成</li>
<li>执行生成命令</li>
</ol>
<p>其中1-5为第一阶段，6-7为第二阶段。</p>
</li>
</ol>
<p><a id="orgf1e2597"></a></p>
<h2 id="_3">书写规则</h2>
<p>规则包含两个部分,一个是依赖关系,一个是生成目标的方法。
Makefile中只应该有一个最终目标，一般第一条规则中的目标被确立为最终目标。</p>
<ol>
<li>
<p>规则举例</p>
<p>foo.o: foo.c defs.h # foo模块
    cc -c -g foo.c
1.文件的依赖关系：foo.o依赖于foo.c和defs.h，如果foo.c和defs.h文件日期比foo.o新，或foo.o不存在，那么依赖关系发生
2.如果生成（或更新）foo.o文件，也就是cc命令，说明了如何生成foo.o这个文件</p>
</li>
<li>
<p>规则的语法</p>
<p>targets: prerequisites
command
&#x2026;
或
targets: prerequisites ; command
command
&#x2026;</p>
<ul>
<li>targets是文件名，以空格分开，可以使用通配符，一般目标是一个文件，也可能是多个文件</li>
<li>command是命令行，如果不和targets: prerequisites在一行，必须以TAB开头，在一行则用分号分隔</li>
<li>prerequisites是目标所依赖的文件（或依赖目标）</li>
<li>如果命令太长，可以使用\换行</li>
</ul>
</li>
<li>
<p>在规则中使用通配符</p>
<p>make支持3个通配符：**  ?  [&#x2026;]</p>
<ul>
<li>常见错误： objects = **.o</li>
</ul>
<p>这里的[**.o]并不会展开，而是跟宏一样，objects的值就是**.o，可以使用关键字wildcard，
objects := $(wildcard **.o)</p>
</li>
<li>
<p>文件搜寻</p>
<p>大型工程的源文件通常要分类到不同目录中，make需要去寻找文件的依赖关系</p>
<ul>
<li>VPATH特殊变量
    Makefile中特殊变量"VPATH"就是完成这个功能的，如果没有指明，make只在当前目录寻找依赖文件和目标文件
    如果定义了VPATH，make在当前目录找不到的情况下，到指定目录中去寻找文件
    VPATH = src:../headers
    上面指定了2个目录，"src"和"../headers"，目录由冒号分隔（当前目录永远是最高优先搜索的地方）</li>
<li>
<p>vpath关键字（更灵活）
    3种使用方法：</p>
<ol>
<li>vpath <pattern> <directories>
    为符合模式<pattern>的文件指定搜索目录<directories></li>
<li>vpath <pattern>
    清除符合模式<pattern>的文件的搜索目录</li>
<li>vpath
    清除所有已被设置好了的文件搜索目录</li>
</ol>
<p><pattern>中需要包含“%”字符，"%"意思是匹配零或若干字符，例如"%.h"表示所有以".h"结尾的文件
<pattern>指定了要搜索的文件集，而<directories>指定了<pattern>的文件集搜索的目录，例如：
vpath %.h ../headers
若多个vpath语句出现相同/重复<pattern>，那么按语句顺序先后执行搜索</p>
</li>
</ul>
</li>
<li>
<p>伪目标</p>
<ul>
<li>clean就是一个伪目标，并不生成"clean"这个文件，伪目标只是一个标签
    clean:
    rm **.o temp</li>
<li>通过特殊标记".PHONY"来显示指明一个目标是伪目标：
    .PHONY: clean
    clean:
    rm **.o temp</li>
<li>伪目标一般没有依赖的文件</li>
</ul>
</li>
<li>
<p>多目标</p>
<ul>
<li>自动化变量"$@"，这个变量表示着目前规则中所有的目标的集合
    多个目标同时依赖于一个文件</li>
<li>example:
    bigoutput littleoutput : text.g
    generate text.g -$(subst output,,$@) &gt; $@
      上述规则相当于：
      bigoutput : text.g
      generate text.g -big &gt; bigoutput
      littleoutput : text.g
      generate text.g -little &gt; littleoutput
      其中，-$(subst output,,$@)中的"$"表示执行一个Makefile的函数，函数名为subst，后面的为参数。
    subst函数是截取字符串的意思，"$@"表示目标的集合，就像一个数组，"$@"依次取出目标，并执行命令。</li>
</ul>
</li>
<li>
<p>静态模式</p>
<p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加有弹性和灵活。
语法：
<targets &#x2026;> : <target-pattern> : <prereq-pattern &#x2026;>
<command>
&#x2026;</p>
<ul>
<li>targets定义了一系列的目标文件，可以有通配符，是目标的一个集合</li>
<li>target-pattern指明了targets的模式，也就是目标集的模式</li>
<li>prereq-patterns是目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义</li>
<li>example:
    objects = foo.o bar.o
    all: $(objects)
    $(objects): %.o : %.c
    $(CC) -c $(CFLAGS) $&lt; -o $@
      其中，"$&lt;"表示所有的依赖目标集（也就是"foo.c bar.c"），"$@"表示目标集（也就是"foo.o bar.o"）
    于是，上面的规则展开后等价于：
    foo.o : foo.c
    $(CC) -c $(CFLAGS) foo.c -o foo.o
    bar.o : bar.c
    $(CC) -c $(CFLAGS) bar.c -o bar.o</li>
</ul>
</li>
<li>
<p>自动生成依赖性</p>
<p>gcc -MM xxx.c输出依赖关系</p>
</li>
</ol>
<p><a id="orgee36bab"></a></p>
<h2 id="_4">书写命令</h2>
<ol>
<li>
<p>显示命令</p>
</li>
<li>
<p>命令执行</p>
<p>如果要让上一条命令的结果应用在下一条命令，应该用分号分隔两条命令，写在一行，例：
exec:
cd /home/yang
pwd
和
exec:
cd /home/yang ; pwd
后者正确</p>
</li>
<li>
<p>命令出错</p>
<ul>
<li>“-”（在TAB之后）减号标记命令不管出不出错都认为是成功的，如：
    clean:
    -rm -f **.o</li>
<li>make -i 或 &#x2013;ignore-errors参数，全局方法，忽略所有命令的错误</li>
<li>make -k 或 &#x2013;keep-going，如果命令出错，继续执行其他规则</li>
</ul>
</li>
<li>
<p>嵌套执行make</p>
<ul>
<li>大工程可以在不同目录写一个该目录的Makefile，这样不会太乱，方便维护。总控的Makefile可以这样写：</li>
</ul>
<p>subsystem:
cd subdir &amp;&amp; $(MAKE)
等价于
subsystem:
$(MAKE) -C subdir</p>
<ul>
<li>传递/不传递变量到下级Makefile中
    export <variable &#x2026;>
    unexport <variable &#x2026;>
    例：
    export variable = value
    等价于：
    variable = value
    export variable
    等价于：
    export variable := value
    等价于：
    variable := value
    export variable</li>
<li>如果要传递所有变量，只需要一个export，后面什么都不跟，表示传递所有变量</li>
</ul>
</li>
<li>
<p>定义命令包</p>
<p>如果Makefile中出现一些相同命令序列，那么可以为这些相同的命令序列定义一个变量。
语法：以define开始，以endef结束，如：
define run-yacc
yacc $(firstword $^)
mv y.tab.c $@
endef
这里，run-yacc是命令包的名字，不要和Makefile中变量重名。</p>
</li>
</ol>
<p><a id="org492bbdb"></a></p>
<h2 id="_5">使用变量</h2>
<p>Makefile中变量名可以包含字符、数字、下划线（可以以数字开头）
但不能包含":"、"#"、"="、或是空字符（空格、回车等）
变量是大小写敏感的
传统的Makefile变量名是全大写的命名方式</p>
<ol>
<li>
<p>变量的基础</p>
<p>变量声明时需要给予初值，使用时需要在变量名前加上"$"符号，但最好用小括号()或大括号{}把变量包起来，
如果要用"$"字符，用"$$"表示。变量就是“替代”的作用。</p>
</li>
<li>
<p>变量中的变量</p>
<p>变量可以使用后面的变量来定义：
foo = $(bar)
bar = $(ugh)
ugh = Huh?
all:
echo $(foo)</p>
<ul>
<li>好处：可以把变量的真实值推到后面定义
    CFLAGS = $(include<sub>dirs</sub>) -O
    include<sub>dirs</sub> = -Ifoo -Ibar</li>
<li>坏处：递归定义，无限展开
    CFLAGS = $(CFLAGS) -O
    或
    A = $(B)
    B = $(A)
    为了避免这样，我们使用make中另一种用变量来定义变量的方法，使用":="操作符：
    x := foo
    y := $(x) bar
    x := later
    等价于：
    y := foo bar
    x := later
    这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量：
    y := $(x) bar
    x := foo
    那么y的值是bar，而不是foo bar</li>
</ul>
</li>
<li>
<p>变量高级用法</p>
<ol>
<li>
<p>变量值的替换</p>
<ul>
<li>替换变量中共有的部分，格式是"$(var:a=b)"或"${var:a=b}"，意思是把变量var中所有以a结尾（空格或结束符）的a替换成b</li>
<li>example
    foo := a.o b.o c.o
    bar := $(foo:.o=.c)
    这里bar的值为a.c b.c c.c</li>
<li>静态模式替换
    foo := a.o b.o c.o
    bar := $(foo:%.o=%.c)</li>
</ul>
</li>
<li>
<p>把变量的值再当成变量</p>
<p>简单的例子：
x = y
y = z
a := $($(x))
复杂的例子：
x = variable1
variable2 := Hello
y = $(subst 1,2,$(x))
z = y
a := $($($(z)))</p>
</li>
</ol>
</li>
<li>
<p>追加变量值</p>
<p>使用“+=”给变量追加值，如：
objects = main.o foo.o bar.o utils.o
objects += another.o
等同于
objects = main.o foo.o bar.o utils.o
objects := $(objects) another.o</p>
<ul>
<li>如果变量之前没有定义过，那么"+="会自动变成"="</li>
<li>如果定义过，那么"+="会继承于前次操作的赋值符</li>
<li>如果前一次是":="，那么"+="会以":="作为其赋值符</li>
<li>example</li>
</ul>
<p>variable := value
variable += more
等价于
variable := value
variable := $(variable) more
但如果是
variable = value
variable += more
此时+=会以=来做为赋值</p>
</li>
<li>
<p>TODO override指示符(pg38)</p>
</li>
<li>
<p>多行变量</p>
</li>
<li>
<p>环境变量</p>
</li>
<li>
<p>目标变量</p>
</li>
<li>
<p>模式变量</p>
</li>
</ol>
<p><a id="org1fa0019"></a></p>
<h2 id="_6">使用条件判断</h2>
<p><a id="org47b5f87"></a></p>
<h2 id="_7">使用函数</h2>
<p><a id="orgfbe4503"></a></p>
<h2 id="make">make的运行</h2>
<p><a id="org140df06"></a></p>
<h2 id="_8">隐含规则</h2>
<p><a id="orgdce9234"></a></p>
<h2 id="make_1">使用make更新函数库文件</h2>
<p><a id="orgdb4c6a9"></a></p>
<h2 id="_9">后序</h2>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
